#Kabopan - Readable Algorithms. Public Domain, 2007-2009
"""
Cyclic redundancy check.

Cyclic Codes for Error Detection.
William Wesley Peterson and Brown, D. T.
1961


a CRC is actually the remainder of a division of the message by a specific polynom, in GF(2).
each CRC standard use a different polynom.

in GF(2), getting the remainder of a division is the equivalent of xoring
by the root generated by the polynom, minus the highest degree
"""

from kbp._misc import MASK

def root_to_poly(root, width=None):
    """generates a polynom representation from its root.
    the highest degree monom can't be guessed though if width is not entered"""

    value = root
    monoms = list()
    for i in range(64):
        if value == 0:
            break
        if (value & 1) == 1:
            if i == 0:
                monoms.append("1")
            elif i == 1:
                monoms.append("x")
            else:
                monoms.append("x^%i" % i)
        value >>= 1
    if width is not None:
        monoms.append("x^%i" % width)
    poly = " + ".join(reversed(monoms))
    return poly

POLY_ZMODEM = "x^16 + x^12 + x^5 + 1"
POLY_CRC32 = "x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1"
POLY_CRC16 = "x^16 + x^15 + x^2 + 1"

CRCs = {

    "crc-8":{"polynom":"x^8 + x^2 + x + 1"},
    "dallas-1-wire":{"polynom":"x^8 + x^5 + x^4 + 1",
        'in_reflection': True, 'out_reflection': True},

    #16 bits
    "crc-16":{"polynom":POLY_CRC16,
        'in_reflection': True, 'out_reflection': True},
    "crc-16-usb":{"polynom":POLY_CRC16,
        'in_reflection': True, 'out_reflection': True, "out_xor": True, "init":0xFFFF},

    "ccitt":{"polynom":POLY_ZMODEM,
        "init":0xFFFF, 'out_reflection': False},
    "kermit":{"polynom":POLY_ZMODEM,
        'in_reflection': True, 'out_reflection': True},
    "x-25":{"polynom":POLY_ZMODEM,
        'in_reflection': True, 'out_reflection': True, "out_xor": True, "init":0xFFFF},
    "zmodem":{"polynom":POLY_ZMODEM,
        'out_reflection': False},

    "xmodem":{"polynom":"x^16 + x^15 + x^10 + x^3",
        'in_reflection': True, 'out_reflection': True},
    #24 bits
    "crc-24":{"polynom":"x^24 + x^23 + x^18 + x^17 + x^14 + x^11 + x^10 + x^7 + x^6 + x^5 + x^4 + x^3 + x + 1",
        'init': 0xB704CE, 'out_reflection': False},
    #32 bits
    "CRC32_IEEE":{
        "polynom": POLY_CRC32,
        "in_reflection":True, "out_reflection":True, "out_xor":True, "init":0xFFFFFFFF},
    "posix":{"polynom":POLY_CRC32,
        "out_xor": True},
    "jam":{"polynom":POLY_CRC32,
        'in_reflection': True, "init":0xFFFFFFFF, 'out_reflection': True},
    "crc-32c":{"polynom":"x^32 + x^28 + x^27 + x^26 + x^25 + x^23 + x^22 + x^20 + x^19 + x^18 + x^14 + x^13 + x^11 + x^10 + x^9 + x^8 + x^6 + 1",
        'in_reflection': True, 'out_reflection': True, "out_xor": True, "init":0xFFFFFFFF},
    "xfer":{"polynom":"x^32 + x^7 + x^5 + x^3 + x^2 + x + 1"},

    #64 bits
    "CRC-64-ISO":{
        "polynom": "x^64 + x^4 + x^3 + x + 1",
        'in_reflection': True, 'out_reflection': True},
}


DISABLED_CRCs = {
    #the parameters for these CRCs and polynoms are unknown
    "CRC-1":{
            "polynom": "x + 1",},
    "CRC-4-ITU":{
            "polynom": "x^4 + x + 1",},
    "CRC-5-ITU":{
            "polynom": "x^5 + x^4 + x^2 + 1",},
    "CRC-6-ITU":{
            "polynom": "x^6 + x + 1",},
    "CRC-7":{
            "polynom": "x^7 + x^3 + 1",},
    "CRC-8-CCITT":{
            "polynom": "x^8 + x^7 + x^3 + x^2 + 1",},
    "CRC-8":{
            "polynom": "x^8 + x^7 + x^6 + x^4 + x^2 + 1",},
    "CRC-8-SAE J1850":{
            "polynom": "x^8 + x^4 + x^3 + x^2 + 1",},
    "CRC-10":{
            "polynom": "x^10 + x^9 + x^5 + x^4 + x + 1",},
    "CRC-11":{
            "polynom": "x^11 + x^9 + x^8 + x^7 + x^2 + 1",},
    "CRC-12":{
            "polynom": "x^12 + x^11 + x^3 + x^2 + x + 1",},
    "CRC-16-DNP":{
            "polynom": "x^16 + x^13 + x^12 + x^11 + x^10 + x^8 + x^6 + x^5 + x^2 + 1",},
    "CRC-30":{
            "polynom": "x^30 + x^29 + x^21 + x^20 + x^15 + x^13 + x^12 + x^11 + x^8 + x^7 + x^6 + x^2 + x + 1",},
    "CRC-32K":{
            "polynom": "x^32 + x^30 + x^29 + x^28 + x^26 + x^20 + x^19 + x^17 + x^16 + x^15 + x^11 + x^10 + x^7 + x^6 + x^4 + x^2 + x + 1",},
    "CRC-64-ECMA-182":{
        "polynom": "x64 + x62 + x57 + x55 + x54 + x53 + x52 + x47 + x46 + x45 + x40 + x39 + x38 + x37 + x35 +"
                    " x33 + x32 + x31 + x29 + x27 + x24 + x23 + x22 + x21 + x19 + x17 + x13 + x12 + x10 + x9 + x7 + x4 + x + 1",},

    # uneven sizes are unsupported
    "crc-5":{"polynom":"x^5 + x^2 + 1",
        'in_reflection': True, 'out_reflection': True, "out_xor": True, 'init': 0x1F},
    "crc-15":{"polynom":"x^15 + x^14 + x^10 + x^8 + x^7 + x^4 + x^3 + 1",
        'out_reflection': False},
    #disabled for now
    "r-crc-16":{"polynom":"x^16 + x^10 + x^8 + x^7 + x^3 + 1",
        'out_xor': True}, # TODO: check weird out_xor
}



from kbp._misc import getpadbinstr, getvaluefrombinarystring
import kbp._bits as _bits

def get_exponents(polynom_string):
    polynom_string = polynom_string.replace(" ", "").replace("**", "").replace("^", "")       # strip whitespace

    monoms = polynom_string.split("+")
    exponents = []
    for monom in monoms:
        if monom == "x":
            exponents.append(1)
        elif monom.startswith("x"):
            exponent = monom[1:]
            exponents.append(int(exponent))
        elif monom == "1":
            exponents.append(0)
    return exponents


def or_all(generator):
    result = 0
    for i in generator:
        result |= i
    return result


def generate_root(polynom):
    exponents = get_exponents(polynom)
    # assert polynom == sorted(polynom, reverse=True)
    width = max(exponents) # polynom[0]

    # the number whose all bits of an exponent are sets, except the highest one
    all_bits = or_all(1 << i for i in exponents)
    highest_bit = 1 << width
    polynomial_constant = all_bits ^ highest_bit

    constant_bitstring = getpadbinstr(polynomial_constant, width)
    reverse_bitstring = constant_bitstring[::-1]
    reverse_constant = getvaluefrombinarystring(reverse_bitstring)

    return polynomial_constant, reverse_constant, width


def crc(message, polynom, init=0, in_reflection=False, out_reflection=False, out_xor=False):
    root, reversed_, width = generate_root(polynom)

    # we have to augment the string with 'width' bits
    augmented_message = message + "\x00" * (width / 8)

    #if no IN reflection is needed, we'll work in bit 7 first mode.
    bit7_first = not in_reflection

    bits = _bits.bits(augmented_message, bit7_first)
    if width in MASK:
        mask = MASK[width]
    else:
        mask = (1 << width) - 1
    reg = init

    #TODO: why ? check http://www.tty1.net/pycrc/#download
    for i in xrange(width):
        lowest_bit_set = (reg & 1) == 1
        if lowest_bit_set:
            reg ^= root
        reg = (reg >> 1) | (lowest_bit_set << (width - 1))


    for new_read_bit in bits:
        highest_reg_bit_set = (((reg >> (width - 1)) & 1) == 1)
        reg = ((reg << 1) & mask) | int(new_read_bit)
        if highest_reg_bit_set:
            reg ^= root

    if out_reflection:
        reg = _bits.reverse(reg, width)

    if out_xor:
        reg = ~reg
    reg &= mask
    return reg, width


def crc32_ieee(message):
    return crc(message, **CRCs["CRC32_IEEE"])[0]

def crc32_ieee_hexhash(message):
    value, width = crc(message, **CRCs["CRC32_IEEE"])
    return ("%X" % value).ljust(width / 4, "0")

if __name__ == '__main__':
    import kbp.test.crc_test

    tests = [
    #TODO: lack of support for uneven sizes
    #['crc-5', 0x19],
    #['crc-15', 0x59e],
    ['crc-8', 0xf4],
    ['dallas-1-wire', 0xa1],
    ['crc-16', 0xbb3d],
    ['crc-16-usb', 0xb4c8],
    ['ccitt', 0x29b1],
    #disabled, weird xor_out parameter
    #['r-crc-16', 0x7e], 
    ['kermit', 0x2189],
    ['x-25', 0x906e],
    ['xmodem', 0xc73],
    ['zmodem', 0x31c3],
    ['crc-24', 0x21cf02],
    ['CRC32_IEEE', 0xcbf43926],
    ['crc-32c', 0xe3069283],
    ['posix', 0x765e7680],
    ['jam', 0x340bc6d9],
    ['xfer', 0xbd0be338],
    ['CRC-64-ISO', 0x46a5a9388a5beffe]]
    
    for crc_name, expected_value in tests:
        try:
            result, width =  crc("123456789", **CRCs[crc_name])
        except AttributeError:
            print "attriberror", crc_name
        if result != expected_value:
            print crc_name
